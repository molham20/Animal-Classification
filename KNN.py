# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1U5GpGHmGKYcBOI3Q0Yec1W5_sVabQo6d
"""

import os
import numpy as np
from PIL import Image
from collections import Counter
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.preprocessing import LabelEncoder
import time
from tqdm import tqdm
from concurrent.futures import ThreadPoolExecutor
from tensorflow.keras.applications.vgg16 import VGG16, preprocess_input
from tensorflow.keras.preprocessing.image import img_to_array

class Config:
    IMAGE_SIZE = (224, 224)
    DATASET_PATH = "/content/Data/Data"
    TEST_SIZE = 0.2
    RANDOM_STATE = 42
    K = 5
    SAMPLE_LIMIT = None
    N_JOBS = 4
    NORMALIZE = True

cnn_model = VGG16(weights='imagenet', include_top=False, pooling='avg')

class FeatureExtractor:
    @staticmethod
    def extract_features(image_array):
        img = np.expand_dims(image_array, axis=0)
        img = preprocess_input(img)
        features = cnn_model.predict(img, verbose=0)
        return features.flatten()

class DataLoader:
    @staticmethod
    def load_images(folder_path):
        images, labels = [], []
        class_names = sorted(os.listdir(folder_path))

        with ThreadPoolExecutor(max_workers=Config.N_JOBS) as executor:
            futures = []
            for label in class_names:
                class_folder = os.path.join(folder_path, label)
                filenames = os.listdir(class_folder)[:Config.SAMPLE_LIMIT]

                for filename in filenames:
                    futures.append(executor.submit(
                        DataLoader._process_image,
                        class_folder, filename, label
                    ))

            for future in tqdm(futures, desc="Loading images"):
                result = future.result()
                if result:
                    img_features, lbl = result
                    images.append(img_features)
                    labels.append(lbl)

        return np.array(images), np.array(labels)

    @staticmethod
    def _process_image(class_folder, filename, label):
        try:
            img_path = os.path.join(class_folder, filename)
            img = Image.open(img_path).convert('RGB')
            img = img.resize(Config.IMAGE_SIZE)
            img_array = np.array(img).astype(np.float32)

            features = FeatureExtractor.extract_features(img_array)
            return features, label
        except Exception as e:
            print(f"Skipping {filename}: {str(e)}")
            return None

class KNNClassifier:
    def __init__(self, k=5):
        self.k = k
        self.X_train = None
        self.y_train = None
        self.le = LabelEncoder()

    def fit(self, X, y):
        self.X_train = X
        self.y_train = self.le.fit_transform(y)

        if Config.NORMALIZE:
            self.mean = np.mean(self.X_train, axis=0)
            self.std = np.std(self.X_train, axis=0)
            self.X_train = (self.X_train - self.mean) / (self.std + 1e-8)

    def predict(self, X_test):
        if Config.NORMALIZE:
            X_test = (X_test - self.mean) / (self.std + 1e-8)

        predictions = []
        for x_test in tqdm(X_test, desc="Predicting"):
            distances = 1 - np.dot(self.X_train, x_test) / (
                np.linalg.norm(self.X_train, axis=1) * np.linalg.norm(x_test) + 1e-8)

            k_indices = np.argpartition(distances, self.k)[:self.k]
            k_nearest_labels = self.y_train[k_indices]
            most_common = Counter(k_nearest_labels).most_common(1)
            predictions.append(most_common[0][0])

        return self.le.inverse_transform(predictions)

if __name__ == "__main__":
    print("Loading and preprocessing dataset...")
    X, y = DataLoader.load_images(Config.DATASET_PATH)
    print(f"\nLoaded {len(X)} images with {len(np.unique(y))} classes")

    X_train, X_test, y_train, y_test = train_test_split(
        X, y,
        test_size=Config.TEST_SIZE,
        random_state=Config.RANDOM_STATE,
        stratify=y
    )

    knn = KNNClassifier(k=Config.K)
    print("\nTraining classifier...")
    knn.fit(X_train, y_train)

    print("\nEvaluating on test set...")
    start_time = time.time()
    y_pred = knn.predict(X_test)
    elapsed = time.time() - start_time

    accuracy = np.mean(y_pred == y_test)
    print(f"\nEvaluation completed in {elapsed:.2f} seconds")
    print(f"Accuracy: {accuracy:.2%}")
    print("\nClassification Report:")
    print(classification_report(y_test, y_pred))
    print("\nConfusion Matrix:")
    print(confusion_matrix(y_test, y_pred))